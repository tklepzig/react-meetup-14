<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>reveal.js</title>

    <link rel="stylesheet" href="dist/reset.css" />
    <link rel="stylesheet" href="dist/reveal.css" />
    <link rel="stylesheet" href="dist/theme/my.css" />

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/zenburn.css" />
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section data-markdown>
          <textarea data-template>
            # What's New Out There
            (in React and TypeScript)
          </textarea>
        </section>

        <section>
          <section data-markdown>
            <textarea data-template>
              # Satisfies
            </textarea>
          </section>

          <section>
            <pre>
              <code class="ts" data-line-numbers="1-6|1-8">
              <script type="text/template">const colors: Record<Color, HexColor | RGB> = {
  FancyBlue: { value: "blue" },
  //Nope, doesn't match HexColor | RGB
  DarkBlack: [0, 0, 0],
  BrightWhite: "#fff",
};

//Nope, toUpperCase doesn't exist on RGB
colors.BrightWhite.toUpperCase();
              </script>
              </code>
            </pre>
          </section>

          <section>
            <pre>
              <code class="ts" data-line-numbers>
              <script type="text/template">const colors = {
  FancyBlue: "#00f",
  DarkBlack: [0, 0, 0],
  BrightWhite: "#fff",
} satisfies Record<Color, HexColor | RGB>;

//All fine
colors.BrightWhite.toUpperCase();
              </script>
              </code>
            </pre>
          </section>

          <section data-markdown>
            <textarea data-template>
              ### Custom type from object, but type safe
              Live sample, see `live-samples/satisfies.ts`
            </textarea>
          </section>

          <section data-markdown>
            <textarea data-template>
              ## Benefits
              - Get type safety for union types without using discriminant
              - No `as Type` necessary which can lead to mistakes
              - Implicit types more strict
            </textarea>
          </section>
        </section>

        <section>
          <section data-markdown>
            <textarea data-template>
              # `const` in Type Parameters
            </textarea>
          </section>

          <section>
            <h3><code>as const</code></h3>
            <pre>
              <code class="ts" data-line-numbers="1-3|1-6|1-3,8,9">
              <script type="text/template">type Names = readonly string[];

const getNames = <T extends Names>(arg: T): T => arg;

const names = getNames(["Ed", "Kelly", "Gordon"]);
// Type of names: string[]

const namesConst = getNames(["Ed", "Kelly", "Gordon"] as const);
//Type of namesConst: readonly ["Ed", "Kelly", "Gordon"]
              </script>
              </code>
            </pre>
          </section>

          <section>
            <h3><code>&lt;const T&gt;</code></h3>
            <pre> <code class="ts" data-line-numbers> <script type="text/template">type Names = readonly string[];

const getNamesConst = <const T extends Names>(arg: T): T => arg;

const namesConst = getNamesConst(["Ed", "Kelly", "Gordon"]);
//Type of namesConst: readonly ["Ed", "Kelly", "Gordon"]</script></code></pre>
          </section>

          <section data-markdown>
            <textarea data-template>
              ## Benefits
              - The consumer of a function doesn't need to take care of ensuring const type
              - Supplying whatever functionality with const type is hidden in the encapsulation
            </textarea>
          </section>
        </section>

        <section>
          <section data-markdown>
            <textarea data-template>
              # Concurrent React
            </textarea>
          </section>

          <section data-markdown>
            <textarea data-template>
              ## useTransition
              Short Code Snippet
              Running Beispiel, Mit und Ohne
            </textarea>
          </section>

          <section data-markdown>
            <textarea data-template>
              ## startTransition
              Short Code Snippet
              Running Beispiel, Mit und Ohne
            </textarea>
          </section>

          <section data-markdown>
            <textarea data-template>
              ## useDeferredValue
              Short Code Snippet
              Running Beispiel, Mit und Ohne
            </textarea>
          </section>

          <section data-markdown>
            <textarea data-template>
              ## Suspense
              Server-side benefits
              Code Beispiel slide-only, Bsp. mit next.js
            </textarea>
          </section>
        </section>

        <section>
          <section data-markdown>
            <textarea data-template>
              # New Hook: `useId`
            </textarea>
          </section>

          <section>
            <pre>
              <code class="ts" data-line-numbers>
              <script type="text/template">const passwordHintId = useId();

<label>
  Password:
  <input type="password" aria-describedby={passwordHintId} />
</label>

<p id={passwordHintId}>
  The password must contain letters and numbers.
</p>
              </script>
              </code>
            </pre>
          </section>

          <section data-markdown>
            <textarea data-template>
              ## Benefits
              - Ensures unique ids for accessibility purposes
              - Works for client and server-side components
              - <span class="alert">Attention</span>: Must not be used for generating keys in enumerations!
            </textarea>
          </section>
        </section>

        <section>
          <section data-markdown>
            <textarea data-template>
              # Automatic Batching
            </textarea>
          </section>

          <section data-markdown>
            <textarea data-template>
              ### Batching in React
              - Combine different state updates to avoid too many re-render cycles  
              <span class="highlight">--&rarr;</span> Calling two different <span class="highlight">setState</span> in a row will re-render only once
              - React 17 batched only during browser event
            </textarea>
          </section>

          <section>
            <pre>
              <code class="ts" data-line-numbers>
              <script type="text/template">const handleClick = () => {
  setState1(21);
  setState2(42);
}
              </script>
              </code>
            </pre>
            One re-render
          </section>

          <section>
            <pre>
              <code class="ts" data-line-numbers>
              <script type="text/template">const handleClick = async () => {
  const result = await doSthAsync();
  setState1(21);
  setState2(42);
}
              </script>
              </code>
            </pre>
            <span class="alert">Re-renders twice!</span>
          </section>

          <section data-markdown>
            <textarea data-template>
              ### Automatic Batching in React 18
              - Combines all state updates beginning from `createRoot`
                - `setState`
                - `setTimeout`, `setInterval`
                - Asynchronous Operations
                - Event Handlers
                - ...
            </textarea>
          </section>

          <section>
            <h3>With React 18</h3>
            <pre>
              <code class="ts" data-line-numbers>
              <script type="text/template">const handleClick = async () => {
  const result = await doSthAsync();
  setState1(21);
  setState2(42);
}
              </script>
              </code>
            </pre>
            <span class="highlight">Only one re-render</span>
          </section>

          <section>
            <h3>Force re-render cycles</h3>
            <pre>
              <code class="ts" data-line-numbers>
              <script type="text/template">const handleClick = async () => {
  const result = await doSthAsync();
  flushSync(() => {
    setState1(21);
  });
  flushSync(() => {
    setState2(42);
  });
}
              </script>
              </code>
            </pre>
          </section>
        </section>

        <section>
          <section>
            <h2>Some CSS...</h2>
            <img
              src="https://preview.redd.it/bptzx7ur4uj11.jpg?auto=webp&s=e6660e4545b2463db71c4acb481624730914f8e1"
              alt=""
              style="height: 50vh"
            />
          </section>

          <section data-markdown>
            <textarea data-template>
              ## New pseudo-class `:has()`
            </textarea>
          </section>
        </section>

        <section>
          <img src="https://i.imgflip.com/yew6h.jpg" alt="" />
        </section>
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
        controlsTutorial: false,
        hash: true,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
      });
    </script>
  </body>
</html>
